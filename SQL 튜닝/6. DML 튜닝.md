
## 1. 기본 DML 튜닝

### 인덱스와 DML 성능

- 테이블에 레코드를 입력하려면, 인덱스에도 입력해야 함
    - `DELETE` 도 `INSERT` 와 마찬가지임
- 인덱스는 정렬된 자료구조이므로 수직적 탐색을 통해 입력할 블록을 찾아야 함
- 인덱스는 DML 성능에 영향을 미침

### 무결성 제약과 DML 성능

> 데이터 무결성 규칙
> - 개체 무결성 (Entity Integrity)
> - 참조 무결성 (Referential Integrity)
> - 도메인 무결성 (Domain Integrity)
> - 사용자 정의 무결성 (or 업무 제약 조건)

- PK, FK 제약은 Check, Not Null 제약보다 성능에 더 큰 영향을 미침

### 조건절과 DML 성능

- SELECT문과 실행계획이 다르지 않으므로 여기에는 **인덱스 튜닝 원리**를 그대로 적용할 수 있음

### 서브쿼리와 DML 성능

- SELECT문과 실행계획이 다르지 않으므로 여기에는 **조인 튜닝 원리**를 그대로 적용할 수 있음


### Redo 로깅과 DML 성능

- 오라클은 데이터파일과 컨트롤 파일에 가해지는 모든 변경사항을 Redo 로그에 기록함
- 트랜잭션 데이터가 어떤 이유에서건 유실됐을 때, 트랜잭션을 재현함으로써 유실 이전 상태로 복구하는데 사용함
- DML을 수행할 때마다 Redo 로그를 생성해야 하므로 Redo  로깅은 성능에 영향을 미침


### Undo 로깅과 DML 성능

- Undo == Rollback
- 트랜잭션을 롤백함으로써 현재를 과거 상태로 되돌리는 데 사용함
- 변경된 블록을 이전 상태로 되돌리는 데 필요한 정보를 로깅함
- DML을 수행할 때마다 Undo를 생성해야 하므로 Undo 로깅은 DML 성능에 영향을 미침
    - ==오라클은 Undo 를 생략할 수 있는 방법을 제공하지 않음==


### Lock과 DML 성능

- Lock을 필요 이상으로 자주, 길게 사용하거나 레벨을 높일수록 DML 성능은 느려짐


### 커밋과 DML 성능


#### 커밋의 내부 메커니즘

1) **DB 버퍼 캐시**
- DB에 접속한 사용자를 대신해 모든 일을 처리하는 서버 프로세스는 **버퍼캐시를 통해 데이터를 읽고 씀**
- 버퍼캐시에서 변경된 블록을 모아 주기적으로 데이터파일에 일괄 기록하는 작업은 `DBWR` 프로세스가 맡음

2) **Redo 로그버퍼**
- Redo 로그도 파일이므로 Append 방식으로 기록하더라도 디스크 I/O는 느림
- 해결법
    - Redo 로그 파일에 기록하기 전에 먼저 로그버퍼에 기록함
    - 로그버퍼에 기록한 내용은 나중에 `LGWR` 프로세스가 Redo 로그 파일에 일괄 (batch) 기록함

3) 트랜잭션 데이터 저장 과정
   ![[IMG_FCE862947B5B-1.jpeg|400]]

1) DML 문을 실행하면 Redo 로그버퍼에 변경사항을 기록함
    - **오라클은 데이터를 변경하기 전에 항상 로그부터 기록함**
1) 버퍼블록에서 데이터를 변경함
    - 버퍼캐시에서 블록을 찾지 못하면, 데이터파일에서 읽는 작업부터함
2) 커밋함
3) LGWR 프로세스가 Redo 로그버퍼 내용을 로그파일에 일괄 저장함 ➡️ `Write Ahead Logging`
4) DBWR 프로세스가 변경된 버퍼블록들을 데이터파일에 일괄 저장함

> 🙀 Redo 로그마저도 휘발성 로그버퍼에 기록한다면 데이터를 안전하게 지킬 수 있나?
> - ➡️ LGWR 프로세스는 서버 프로세스가 커밋을 발행했다고 '신호를 보낼 때도' 깨어나서 활동을 시작함
> - 적어도 커밋시점에는 Redo 로그버퍼 내용을 로그파일에 기록한다는 뜻 ➡️ `Log Force at Commit`


4) **커밋 = 저장버튼**

- 루프를 돌면서 건건이 커밋 : 프로그램 자체 성능이 매우 느려짐
    - LGWR 프로세스가 Redo 로그를 기록하는 작업은 **디스크 I/O 작**업이기 때문
- 오랫동안 커밋하지 않은 채로 데이터를 계속 갱신 : Undo 공간이 부족해져 시스템 장애 상황을 유발할  수 있음


### 데이터베이스 Call과 성능

#### SQL 실행 세 단계

- `Parse Call` : SQL 파싱과 최적화를 수행하는 단계
    - SQL과 실행계획을 라이브러리 캐시에서 찾으면, 최적화 단계는 생략 가능함
- `Execute Call` : 말 그대로 SQL을 실행하는 단계
    - `DML`은 이 단계에서 모든 과정이 끝나지만, `SELECT`문은 Fetch 단계를 거침
- `Fetch Call` : 데이터를 읽어서 사용자에게 결과집합을 전송하는 과정
    - `SELECT` 문에서만 나타남
    - 전송할 데이터가 많을 때는 Fetch Call이 여러번 발생함

****
- `User Call` : 네트워크를 경유해 DBMS 외부로부터 인입되는 Call
    - 3-Tier 아키텍처에서 User Call 은 WAS 서버에서 발생하는 Call
    - 네트워크를 경유하므로 성능에 미치는 영향이 매우 큼
- `Recursive Call` : DBMS 내부에서 발생하는 Call


#### One SQL의 중요성

- Insert Into Select 구문
    - 단 한번의 Call로 처리할 수 있으므로 루프를 돌면서 건건히 Call이 발생하는 로직보다 훨씬 빠름
```SQL
insert into target
select * from source;
```


#### Array Processing 활용

- One SQL을 구현하지 않고도 Call 부하를 줄일 수 있는 방법

```SQL
declare
	cursor c is select * from source;
	type typ_source is table of c%rowtype;
	l_source typ_source;

	l_array_size number default 10000;

	procedure insert_target(p_source in typ_source) is
	begin
		forall i in p_source.first..p_source.last
			insert into target values p_source(i);
		end insert_target;

	begin
		open c;
		loop
			fetch c bulk collect into l_source limit l_array_size;

			insert_target(l_source);

			exit when c%notfound;
		end loop;

		close c;

		commit;

	end;
/
```

- 10,000번에 한 번씩 INSERT 하도록 구현함으로써 백만 번 발생할 Call을 백 번으로 줄였기 때문에 나타난 성능 향상

#### 인덱스 및 제약 해제를 통한 대량 DML 튜닝

- 온라인 트랜잭션 처리 시스템에서는 해제 불가
- 동시 트랜잭션이 없는 대량 데이터 배치 프로그램에서는 기능 해제로 성능 개선 효과를 얻을 수 있음

#### 수정가능 조인 뷰

