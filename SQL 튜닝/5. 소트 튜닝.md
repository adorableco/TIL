- [1. 소트 연산에 대한 이해](#1-소트-연산에-대한-이해)
  - [소트 수행 과정](#소트-수행-과정)
  - [소트 오퍼레이션](#소트-오퍼레이션)
- [2. 소트가 발생하지 않도록 SQL 작성](#2-소트가-발생하지-않도록-sql-작성)
  - [Union vs. Union All](#union-vs-union-all)
  - [Exists 활용](#exists-활용)
  - [조인 방식 변경](#조인-방식-변경)
- [3. 인덱스를 이용한 소트 연산 생략](#3-인덱스를-이용한-소트-연산-생략)
  - [Sort Order By 생략](#sort-order-by-생략)
  - [Top N 쿼리](#top-n-쿼리)
  - [Top N Stopkey 알고리즘](#top-n-stopkey-알고리즘)
  - [최소값/최대값 구하기](#최소값최대값-구하기)
  - [인덱스 이용해 최소/최대값 구하기](#인덱스-이용해-최소최대값-구하기)
  - [Top N 쿼리 이용해 최소/최대값 구하기](#top-n-쿼리-이용해-최소최대값-구하기)
  - [이력 조회](#이력-조회)
  - [INDEX_DESC 힌트 사용](#index_desc-힌트-사용)
  - [Sort Group By 생략](#sort-group-by-생략)
- [4. Sort Area를 적게 사용하도록 SQL 작성](#4-sort-area를-적게-사용하도록-sql-작성)
  - [소트 데이터 줄이기](#소트-데이터-줄이기)
  - [Top N 쿼리의 소트 부하 경감 원리](#top-n-쿼리의-소트-부하-경감-원리)
  - [Top N 쿼리가 아닐 때 발생하는 소트 부하](#top-n-쿼리가-아닐-때-발생하는-소트-부하)
  - [분석함수에서의 Top N 소트](#분석함수에서의-top-n-소트)


*** 

## 1. 소트 연산에 대한 이해

### 소트 수행 과정

- 소트는 기본적으로 PGA에 할당한 Sort Area에서 이루어짐
- 메모리 공간인 Sort Area가 다 차면, 디스크 Temp 테이블스페이스를 활용함

#### 유형
> - **메모리 소트 (In-Memory Sort)** : 전체 데이터의 정렬 작업을 메모리 내에서 완료하는 것
> - **디스크 소트 (To-Disk Sort)** : 할당받은 Sort Area 내에서 정렬을 완료하지 못해 디스크 공간까지 사용하는 경우

- 소트 연산은 메모리 집약적일 뿐만 아니라 CPU 집약적임 ➡️ 쿼리 성능을 좌우하는 요소

&nbsp;

***

### 소트 오퍼레이션

#### 1. Sort Aggregate

- 전체 로우를 대상으로 집계를 수행할 때 나타남
- 실제로 데이터를 정렬하진 않고, Sort Area 를 사용한다는 의미로 이해하면 됨

#### 2. Sort Order By

- 데이터를 정렬할 때 나타남

#### 3. Sort Group By

- 소팅 알고리즘을 사용해 그룹별 집계를 수행할 때 나타남
- 집계할 대상 레코드가 아무리 많아도 Temp 테이블 스페이스를 쓰지 않음

> Group By 절 뒤에 Order By 절을 명시하지 않으면 대부분 **Hash Group By** 방식으로 처리함

> 🍯 그룹핑 결과가 정렬 순서를 보장하지 않음
> - 소팅 알고리즘을 통해 그룹핑한 결과집합은 논리적인 정렬 순서를 갖는 연결 리스트 구조인데 물리적으로 저장된 순서는 논리적 순서와 다를 수 있기 때문

#### 4. Sort Unique

- `서브쿼리 Unnesting` 이 일어날 때 메인 쿼리와 조인하기 전에 중복 레코드부터 제거해야 함 ➡️ 이때 **Sort Unique** 오퍼레이션이 나타남
- `Union`, `Minus`, `Intersect` 같은 집합 연산자를 사용할 때도 **Sort Unique** 오퍼레이션이 나타남
- `Distinct` 연산자를 사용해도 **Sort Unique** 오퍼레이션이 나타남

#### 5. Sort Join

- 소트 머지 조인을 수행할 때 나타남

#### 6. Window Sort

- 윈도우 함수 (=분석 함수)를 수행할 때 나타남


***

## 2. 소트가 발생하지 않도록 SQL 작성

### Union vs. Union All

- 될 수 있으면 `Union All` 을 사용해야 함
    - 중복을 확인하지 않고 두 집합을 단순히 결합하므로 소트 작업을 수행하지 않음


### Exists 활용

- 중복 레코드를 제거할 목적으로 Distinct 연산자를 종종 사용함 ➡️ 부분범위 처리가 불가하고 많은 I/O가 발생함
- `Exists` 서브쿼리는 데이터 존재 여부만 확인하면 되기 때문에 조건절을 만족하는 데이터를 모두 읽지 않음


### 조인 방식 변경

- 해시 조인을 하면 소트 연산을 생략하지 못할 수 있음
- ➡️ **NL 조인하도록 방식을 변경**하면 소트 연산 생략 가능

> 🍯 정렬 기준이 조인 키 컬럼이면 소트 머지 조인도 Sort Order By 연산을 생략할 수 있음



***

## 3. 인덱스를 이용한 소트 연산 생략

### Sort Order By 생략

- Order By 연산을 생략하도록 인덱스를 구성할 수 있음

&nbsp;

***

### Top N 쿼리

#### Top N Stopkey 알고리즘

- ROWNUM 으로 지정한 건수만큼 겨로가 레코드를 얻으면 거기서 바로 멈추는 것

#### 부분범위 처리를 활용한 튜닝 기법, n-tier 환경에서도 쓸모 있는 이유 : 페이징

```SQL
SELECT *  
FROM (  
	  SELECT ROWNUM no,  
			 a.*  
	  FROM (  
		 /*SQL Body */
		) a  
	  WHERE  ROWNUM <= (:page * 10) )  
WHERE  no >= (:page-1)* 10 + 1
```

- Top N 쿼리이므로 ROWNUM으로 지정한 건수만큼 결과 레코드를 얻으면 거기서 바로 멈춤
- SQL Body 부분에는 부분범위 처리가 가능한 SQL을 작성해야 함

#### 페이징 처리 안티패턴

```SQL
SELECT *  
FROM   (SELECT ROWNUM no,  a.*  
	FROM   (SELECT 거래일시,  
				   체결건수,  
				   체결수량,  
				   거래대금  
			FROM   종목거래  
			WHERE  종목코드 = 'KR123456'  
				   AND 거래일시 >= '20180304'  
			ORDER  BY 거래일시)a)  
WHERE  no BETWEEN ( :page - 1 ) * 10 + 1 AND ( :page * 10 )
```

- Top N Stopkey 알고리즘이 작동하지 않음

&nbsp;

***

### 최소값/최대값 구하기


#### 인덱스 이용해 최소/최대값 구하기

- **인덱스는 정렬돼 있으므로 이를 이용**하면 전체 데이터를 읽지 않고도 최소 또는 최대값을 쉽게 찾을 수 있음

#### 인덱스를 이용해 최소값/ 최대값을 구할 수 있는 조건

1. 조건절 컬럼과 MIN/MAX 함수 인자 컬럼이 모두 인덱스에 포함돼 있어야 함
- 즉 테이블 액세스가 발생하지 않아야 함!

- ➡️ 조건을 만족하면 `First Row Stopkey` 알고리즘을 사용함
    - 조건을 만족하는 레코드 하나를 찾았을 때 바로 멈추는 것

#### Top N 쿼리 이용해 최소/최대값 구하기

- `Top N Stopkey` 알고리즘 작동
    - 모든 컬럼이 인덱스에 포함돼 있지 않아도 잘 작동함
- 인라인 뷰를 사용하므로 쿼리가 약간 더 복잡하지만, ==성능 측면에서는 MIN/MAX 쿼리보다 나음==

&nbsp;

***


### 이력 조회

#### INDEX_DESC 힌트 사용

- 인덱스를 역순으로 읽도록 `index_desc` 힌트를 사용하고 첫 번째 레코드에서 바로 멈추도록 rownum <= 1 조건절을 사용하면 됨
- 성능은 확실히 좋음
- 인덱스 구성이 완벽해야만 쿼리가 잘 작동함


> #### 선분 이력이란?
> - 일반적으로 시간의 흐름에 따라 발생하는 상태나 이벤트의 변화를 기록한 데이터의 구조를 뜻함
> - 선분은 시작 시점과 종료 시점을 나타내며, 선분 이력은 이러한 선분들이 시간에 따라 이어진 형태로 데이터를 관리하는 방식

&nbsp;

***


### Sort Group By 생략

- 그룹핑 연산에도 인덱스를 활용할 수 있음!
- Group By에 사용하는 컬럼을 인덱스의 선두 컬럼으로 두면 `Sort Group By` 연산을 생략할 수 있음

```SQL
SORT GROUP BY NOSORT
```
- 부분범위 처리가 가능해짐


&nbsp;

***


## 4. Sort Area를 적게 사용하도록 SQL 작성

- 소트 연산이 불가피하다면 메모리 내에서 처리를 완료할 수 있도록 노력해야 함

&nbsp;

***
### 소트 데이터 줄이기

- 정렬하기 전에 데이터를 가공하여 데이터량이 늘어나면 Sort Area 를 더 많이 사용함


&nbsp;

***
### Top N 쿼리의 소트 부하 경감 원리

- 상위 N개의 결과를 얻기 위해서 N 개 원소를담을 배열 공간만 있으면 됨
    - ➡️ 대상 집합이 아무리 커도 많은 메모리 공간이 필요하지 않음
- 소트 연산 횟수와 Sort Area 사용량을 줄여줌

&nbsp;

***

### Top N 쿼리가 아닐 때 발생하는 소트 부하

- `Top N 소트` 알고리즘이 작동하지 않음
- 메모리 내에서 정렬을 완료할 수 없어서 디스크를 이용해야만 함

### 분석함수에서의 Top N 소트

- 윈도우 함수 중 `rank` 나 `row_number` 함수는 `max` 함수보다 소트 부하가 적음
    - **`Top N 소트` 알고리즘이 작동하기 때문!**