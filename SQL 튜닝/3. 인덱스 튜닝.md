- [1. 테이블 액세스 최소화](#1-테이블-액세스-최소화)
  - [인덱스를 이용하는게 테이블 전체를 스캔할 때보다 느린 경우](#인덱스를-이용하는게-테이블-전체를-스캔할-때보다-느린-경우)
  - [인덱스 클러스터링 팩터 (Clustering Factor)](#인덱스-클러스터링-팩터-clustering-factor)
  - [인덱스 손익 분기점](#인덱스-손익-분기점)
  - [인덱스 컬럼 추가](#인덱스-컬럼-추가)
  - [인덱스만 읽고 처리](#인덱스만-읽고-처리)
  - [인덱스 구조 테이블](#인덱스-구조-테이블-iot--index-organized-table)
  - [클러스터 테이블](#클러스터-테이블)
- [2. 부분범위 처리 활용](#2-부분범위-처리-활용)
  -[부분범위 처리](#부분범위-처리)

## 1. 테이블 액세스 최소화

### 인덱스를 이용하는게 테이블 전체를 스캔할 때보다 느린 경우

> #### 🧩 인덱스 ROWID는 논리적 주소임
> - 물리적으로 직접 연결 ❌
> - 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있음 🅾️
> - 메모리 주소 정보가 아닌 디스크 주소 정보를 이용해 해시 알고리즘으로 버퍼 블록을 찾아감
>   - 버퍼캐시에서 밀려났다가 다시 캐싱되면 다른 공간으로 가기 때문!

> #### I/O 메커니즘 복기 (인덱스 ROWID를 이용한 테이블 액세스가 고비용인 이유)
> 1. 블록을 읽을 때는 디스크로 가기 전에 버퍼캐시부터 찾아봄
> 2. **버퍼캐시에 있으면** : 바로 읽기
> 3. **버퍼캐시에 없으면** : 읽고자하는 DBA를 해시 함수에 입력해서 해시 체임을 찾고 거기서 버퍼헤더를 찾음
> - 버퍼 헤더는 항상 같은 해시 체인에 연결되지만  실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱됨
>   - 이 메모리 주소값을 버퍼 헤더가 가지고 있음

&nbsp;

***

### 인덱스 클러스터링 팩터 (Clustering Factor)

- 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도
- **CF가 좋은 컬럼**에 생성한 인덱스 : 검색 효율 👍👍👍

> #### 🤩 CF가 좋은 컬럼에 인덱스를 생성하면 검색 효율이 좋은 이유
> `버퍼 Pinning` 때문
> - 테이블 블록에 대한 포인터를 바로 해제하지 않고 일단 유지하기 때문에 직전과 같은 테이블 블록을 가리키면 **래치 획득과 해시 체인 과정을 생략하고**
> 바로 테이블 블록을 읽을 수 있음

&nbsp;

***


### 인덱스 손익 분기점

- `Table Full Scan` : 몇 건을 조회하든 성능은 일정함
- `Index 를 이용한 테이블 액세스` : 추출 건수가 많을수록 느려짐
  - **테이블 랜덤 액세스** 때문 ➡️Single Block I/O 방식

&nbsp;

***

### 인덱스 컬럼 추가
- **테이블 액세스 최소화를 위해** 가장 일반적으로 사용하는 튜닝기법

&nbsp;

***

### 인덱스만 읽고 처리
- 쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않게 하는 방법

> - `Covered 쿼리` : 인덱스만 읽어서 처리하는 쿼리
> - `Covered 인덱스` : 그 쿼리에 사용한 인덱스

#### Include 인덱스 (MSSQL, PostgreSQL 등)
- 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능
- 해당 컬럼은 리프블록에 **'만'** ! 저장함
- 
```SQL
create index emp_x01 on emp (deptno) include (sal)
```

- 테이블 랜덤 액세스 횟수를 줄이는 용도로만 사용됨
- 수직적 탐색에는 사용될 수 ❌

&nbsp;

***

### 인덱스 구조 테이블 (IOT : Index-Organized Table)

- 인덱스 리프 블록이 곧 데이터 블록
- ROWID 대신 테이블 데이터를 가지고 있음
- 정렬 상태를 유지하며 데이터를 입력함
- 인위적으로 클러스터링 팩터를 좋게 만드는 방법
- 시퀀셜 방식으로 데이터 액세스
  - 같은 값을 가진 레코들이 100% 정렬돼 있기 때문
- `BETWEEN` 이나 부등호 조건으로 넓은 범위를 읽을 때 유리

&nbsp;

***

### 클러스터 테이블

#### 인덱스 클러스터 테이블
- 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조
- 다중 테이블 클러스터 구조가 가능함
- 클러스터에 테이블을 담기 전에 클러스터 인덱스를 반드시 정의해야 함
  - 클러스터 인덱스는 데이터가 저장될 위치를 찾을 때도 사용하기 때문

```SQL
create cluster  c_dept# (deptno number(2)) index;
```

> #### 🌳 일반 B*Tree 인덱스 구조 사용
> 차이점 : 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫 번째 데이터 블록을 가리킴
> - 클러스터 인덱스의 키 값은 항상 Unique 함

&nbsp;

#### 해시 클러스터 테이블
- 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아감

```SQL
create cluster  c_dept# (deptno number(2)) hashkeys 4;
```

&nbsp;

***

## 2. 부분범위 처리 활용

### 부분범위 처리
- 전체 쿼리 결과집합을 쉼 없이 연속적으로 전송하지 않고, 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것

> #### ✅ 정렬 조건이 있는 경우
> 모든 데이터를 다읽어 정렬을 마쳐야 클라이언트에 데이터 전송을 시작할 수 있기 때문에 전체 범위 처리를 함

&nbsp;

#### Array Size 조정을 통한 Fetch Call 최소화

- **대량 데이터를 파일로 내려받는다면** `Array Size 를 늘려서` Fetch Call 횟수를 줄이는게 좋음
  - 어차피 다 받아야 하기 때문
- **앞쪽 일부 데이터만 Fetch 하다가 멈추는 프로그램**이라면 `Array Size 를 작게` 설정하는 것이 유리함

> #### ✅ 중요! : 멈출 수 있어야 의미 있는 부분 범위 처리
> - 앞쪽 일부만 출력하고 멈출 수 있어야 의미 있음
>   - 클라이언트가 DB 서버에 직접 접속하는 2-Tier 환경에서는 그렇게 구현 가능
> - n-Tier 아키텍처에서는 불가능함


&nbsp;

***

## 3. 인덱스 스캔 효율화

### 인덱스 스캔 효율성

- 인덱스 선행 컬럼이 조건절에 없거나 '=' 조건이 아니면 인덱스 스캔 과정에 비효율이 발생함

> ✅인덱스 리프 블록에는 테이블 블록보다 훨씬 더 많은 레코드가 담김

&nbsp;

***

### 액세스 조건과 필터 조건

#### 인덱스 액세스 조건
- 인덱스 스캔 범위를 결정하는 조건절

#### 인덱스 필터 조건
- 테이블로 액세스할지를 결정하는 조건절

&nbsp;

***

### 비교 연산자 종류와 컬럼 순서에 따른 군집성
- `맨 마지막 컬럼이 아닌 중간 컬럼이 범위검색 조건일 때는` 레코드가 흩어짐

> #### 규칙
> 선행 컬럼이 모두 '=' 조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어짐

> 필터 조건도 범위검색 조건 맨 처음과 마지막 구간에서는 스캔량을 줄이는 데 역할을 함  ➡️ BUT 미미한 수준
> - 이 때문에 오라클에서는 인덱스 컬럼에 대한 조건절이 대부분 액세스 조건으로 표시됨

&nbsp;

***

### 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

- 인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때 가장 좋음
  - 리프 블록을 스캔하면서 읽은 레코드는 하나도 걸러지지 않고 모두 테이블 액세스로 이어지기 때문

- 인덱스 선행 컬럼이 조건절에 없거나 부등호, `BETWEEN`, `LIKE` 같은 범위검색 조건이면 비효율이 생김

&nbsp;

***

### `BETWEEN` 을 **In-List** 로 전환

- `BETWEEN` 을 In-List로바꾸면 수직적 탐색이 N번 발생함
  - 등치(=) 조건으로 여러번 탐색하는 것
- In-List 항목 개수가 늘어날 수 있다면 전환하기에 곤란함
  - NL 방식의 조인문이나 서브쿼리로 구현하면 됨

> #### ⚠️ 주의 사항
> - In-List 개수가 많지 않아야 함
>   - 브랜치 블록을 반복 탐색하는 비효율이 더 커질 수 있기 때문
> - 인덱스 스캔과정에서 선택되는 레코드들이 서로 멀리 덜어져 있을 때만 유용함

&nbsp;

***

### Index Skip Scan 사용

- 선두 컬럼이 `BETWEEN` 이어서 나머지 검색 조건을 만족하는 데이터가 서로 멀리 떨어져 있는 경우에 유용함