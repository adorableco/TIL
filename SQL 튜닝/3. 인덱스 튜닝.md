- [1. 테이블 액세스 최소화](#1-테이블-액세스-최소화)
  - [인덱스를 이용하는게 테이블 전체를 스캔할 때보다 느린 경우](#인덱스를-이용하는게-테이블-전체를-스캔할-때보다-느린-경우)
  - [인덱스 클러스터링 팩터 (Clustering Factor)](#인덱스-클러스터링-팩터-clustering-factor)
  - [인덱스 손익 분기점](#인덱스-손익-분기점)
  - [인덱스 컬럼 추가](#인덱스-컬럼-추가)
  - [인덱스만 읽고 처리](#인덱스만-읽고-처리)
  - [인덱스 구조 테이블](#인덱스-구조-테이블-iot--index-organized-table)
  - [클러스터 테이블](#클러스터-테이블)
- [2. 부분범위 처리 활용](#2-부분범위-처리-활용)
  - [부분범위 처리](#부분범위-처리)
- [3. 인덱스 스캔 효율화](#3-인덱스-스캔-효율화)
  - [인덱스 스캔 효율성](#인덱스-스캔-효율성)
  - [액세스 조건과 필터 조건](#액세스-조건과-필터-조건)
  - [비교 연산자 종류와 컬럼 순서에 따른 군집성](#비교-연산자-종류와-컬럼-순서에-따른-군집성)
  - [인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율](#인덱스-선행-컬럼이-등치-조건이-아닐-때-생기는-비효율)
  - [`BETWEEN` 을 **In-List** 로 전환](#between-을-in-list-로-전환)
  - [Index Skip Scan 사용](#index-skip-scan-사용)
  - [IN 조건은 '=' 인가](#in-조건은--인가)
  - [IN-List 를 액세스 조건 or 필터 조건으로 유도하는 방법](#in-list-를-액세스-조건-or-필터-조건으로-유도하는-방법)
  - [`BETWEEN` 과 `LIKE` 스캔 범위 비교](#between-과-like-스캔-범위-비교)
  - [다양한 옵션 조건 처리 방식의 장단점 비교](#다양한-옵션-조건-처리-방식의-장단점-비교)
  - [함수호출부하 해소를 위한 인덱스 구성 (내용 보충 필요 🔥🔥)](#함수호출부하-해소를-위한-인덱스-구성)
- [4. 인덱스 설계](#4-인덱스-설계)
  - [인덱스 설계가 어려운 이유](#인덱스-설계가-어려운-이유)
  - [가장 중요한 두 가지 선택 기준](#가장-중요한-두-가지-선택-기준)
  - [스캔 효율성 이외의 판단 기준](#스캔-효율성-이외의-판단-기준)
  - [소트 연산을 생략하기 위한 컬럼 추가](#소트-연산을-생략하기-위한-컬럼-추가)
  - [결합 인덱스 선택도](#결합-인덱스-선택도)

***

## 1. 테이블 액세스 최소화

### 인덱스를 이용하는게 테이블 전체를 스캔할 때보다 느린 경우

> #### 🧩 인덱스 ROWID는 논리적 주소임
> - 물리적으로 직접 연결 ❌
> - 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있음 🅾️
> - 메모리 주소 정보가 아닌 디스크 주소 정보를 이용해 해시 알고리즘으로 버퍼 블록을 찾아감
>   - 버퍼캐시에서 밀려났다가 다시 캐싱되면 다른 공간으로 가기 때문!

> #### I/O 메커니즘 복기 (인덱스 ROWID를 이용한 테이블 액세스가 고비용인 이유)
> 1. 블록을 읽을 때는 디스크로 가기 전에 버퍼캐시부터 찾아봄
> 2. **버퍼캐시에 있으면** : 바로 읽기
> 3. **버퍼캐시에 없으면** : 읽고자하는 DBA를 해시 함수에 입력해서 해시 체임을 찾고 거기서 버퍼헤더를 찾음
> - 버퍼 헤더는 항상 같은 해시 체인에 연결되지만  실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱됨
>   - 이 메모리 주소값을 버퍼 헤더가 가지고 있음

&nbsp;

***

### 인덱스 클러스터링 팩터 (Clustering Factor)

- 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도
- **CF가 좋은 컬럼**에 생성한 인덱스 : 검색 효율 👍👍👍

> #### 🤩 CF가 좋은 컬럼에 인덱스를 생성하면 검색 효율이 좋은 이유
> `버퍼 Pinning` 때문
> - 테이블 블록에 대한 포인터를 바로 해제하지 않고 일단 유지하기 때문에 직전과 같은 테이블 블록을 가리키면 **래치 획득과 해시 체인 과정을 생략하고**
> 바로 테이블 블록을 읽을 수 있음

&nbsp;

***


### 인덱스 손익 분기점

- `Table Full Scan` : 몇 건을 조회하든 성능은 일정함
- `Index 를 이용한 테이블 액세스` : 추출 건수가 많을수록 느려짐
  - **테이블 랜덤 액세스** 때문 ➡️Single Block I/O 방식

&nbsp;

***

### 인덱스 컬럼 추가
- **테이블 액세스 최소화를 위해** 가장 일반적으로 사용하는 튜닝기법

&nbsp;

***

### 인덱스만 읽고 처리
- 쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않게 하는 방법

> - `Covered 쿼리` : 인덱스만 읽어서 처리하는 쿼리
> - `Covered 인덱스` : 그 쿼리에 사용한 인덱스

#### Include 인덱스 (MSSQL, PostgreSQL 등)
- 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능
- 해당 컬럼은 리프블록에 **'만'** ! 저장함
- 
```SQL
create index emp_x01 on emp (deptno) include (sal)
```

- 테이블 랜덤 액세스 횟수를 줄이는 용도로만 사용됨
- 수직적 탐색에는 사용될 수 ❌

&nbsp;

***

### 인덱스 구조 테이블 (IOT : Index-Organized Table)

- 인덱스 리프 블록이 곧 데이터 블록
- ROWID 대신 테이블 데이터를 가지고 있음
- 정렬 상태를 유지하며 데이터를 입력함
- 인위적으로 클러스터링 팩터를 좋게 만드는 방법
- 시퀀셜 방식으로 데이터 액세스
  - 같은 값을 가진 레코들이 100% 정렬돼 있기 때문
- `BETWEEN` 이나 부등호 조건으로 넓은 범위를 읽을 때 유리

&nbsp;

***

### 클러스터 테이블

#### 인덱스 클러스터 테이블
- 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조
- 다중 테이블 클러스터 구조가 가능함
- 클러스터에 테이블을 담기 전에 클러스터 인덱스를 반드시 정의해야 함
  - 클러스터 인덱스는 데이터가 저장될 위치를 찾을 때도 사용하기 때문

```SQL
create cluster  c_dept# (deptno number(2)) index;
```

> #### 🌳 일반 B*Tree 인덱스 구조 사용
> 차이점 : 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫 번째 데이터 블록을 가리킴
> - 클러스터 인덱스의 키 값은 항상 Unique 함

&nbsp;

#### 해시 클러스터 테이블
- 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아감

```SQL
create cluster  c_dept# (deptno number(2)) hashkeys 4;
```

&nbsp;

***

## 2. 부분범위 처리 활용

### 부분범위 처리
- 전체 쿼리 결과집합을 쉼 없이 연속적으로 전송하지 않고, 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것

> #### ✅ 정렬 조건이 있는 경우
> 모든 데이터를 다읽어 정렬을 마쳐야 클라이언트에 데이터 전송을 시작할 수 있기 때문에 전체 범위 처리를 함

&nbsp;

#### Array Size 조정을 통한 Fetch Call 최소화

- **대량 데이터를 파일로 내려받는다면** `Array Size 를 늘려서` Fetch Call 횟수를 줄이는게 좋음
  - 어차피 다 받아야 하기 때문
- **앞쪽 일부 데이터만 Fetch 하다가 멈추는 프로그램**이라면 `Array Size 를 작게` 설정하는 것이 유리함

> #### ✅ 중요! : 멈출 수 있어야 의미 있는 부분 범위 처리
> - 앞쪽 일부만 출력하고 멈출 수 있어야 의미 있음
>   - 클라이언트가 DB 서버에 직접 접속하는 2-Tier 환경에서는 그렇게 구현 가능
> - n-Tier 아키텍처에서는 불가능함


&nbsp;

***

## 3. 인덱스 스캔 효율화

### 인덱스 스캔 효율성

- 인덱스 선행 컬럼이 조건절에 없거나 '=' 조건이 아니면 인덱스 스캔 과정에 비효율이 발생함

> ✅인덱스 리프 블록에는 테이블 블록보다 훨씬 더 많은 레코드가 담김

&nbsp;

***

### 액세스 조건과 필터 조건

#### 인덱스 액세스 조건
- 인덱스 스캔 범위를 결정하는 조건절

#### 인덱스 필터 조건
- 테이블로 액세스할지를 결정하는 조건절

&nbsp;

***

### 비교 연산자 종류와 컬럼 순서에 따른 군집성
- `맨 마지막 컬럼이 아닌 중간 컬럼이 범위검색 조건일 때는` 레코드가 흩어짐

> #### 규칙
> 선행 컬럼이 모두 '=' 조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어짐

> 필터 조건도 범위검색 조건 맨 처음과 마지막 구간에서는 스캔량을 줄이는 데 역할을 함  ➡️ BUT 미미한 수준
> - 이 때문에 오라클에서는 인덱스 컬럼에 대한 조건절이 대부분 액세스 조건으로 표시됨

&nbsp;

***

### 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

- 인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때 가장 좋음
  - 리프 블록을 스캔하면서 읽은 레코드는 하나도 걸러지지 않고 모두 테이블 액세스로 이어지기 때문

- 인덱스 선행 컬럼이 조건절에 없거나 부등호, `BETWEEN`, `LIKE` 같은 범위검색 조건이면 비효율이 생김

&nbsp;

***

### `BETWEEN` 을 **In-List** 로 전환

- `BETWEEN` 을 **In-List** 로바꾸면 수직적 탐색이 N번 발생함
  - 등치(=) 조건으로 여러번 탐색하는 것
- In-List 항목 개수가 늘어날 수 있다면 전환하기에 곤란함
  - NL 방식의 조인문이나 서브쿼리로 구현하면 됨

> #### ⚠️ 주의 사항
> - In-List 개수가 많지 않아야 함
>   - 브랜치 블록을 반복 탐색하는 비효율이 더 커질 수 있기 때문
> - 인덱스 스캔과정에서 선택되는 레코드들이 서로 멀리 덜어져 있을 때만 유용함

&nbsp;

***

### Index Skip Scan 사용

- 선두 컬럼이 `BETWEEN` 이어서 나머지 검색 조건을 만족하는 데이터가 서로 멀리 떨어져 있는 경우에 유용함

&nbsp;

***

### IN 조건은 '=' 인가

- 답은 NO!!
- In-List Iterator 방식으로 풀릴 때만 IN 조건이 '=' 조건처럼 작동함
  - 그렇지 않으면 IN 조건은 **필터 조건**임

### IN-List 를 액세스 조건 or 필터 조건으로 유도하는 방법

> #### 🍯 `NUM_INDEX_KEYS` 힌트 활용
> `/*+ num_index_keys(인덱스명 n) */`
> - 인덱스 n 번째 컬럼까지만 액세스 조건으로 사용하라는 의미

> #### 🍯 인덱스 컬럼 가공하기
> ```SQL
> select *
> from 고객별 가입상품
> where 고객번호 = :cust_no
> and PTRIM(상품ID) in ('NH0037', 'NH0041') 
> and 상품ID || '' in ('NH0037', 'NH0041') 

&nbsp;

***

### `BETWEEN` 과 `LIKE` 스캔 범위 비교

- `LIKE` 보다 `BETWEEN` 을 사용하는게 나음

&nbsp;

***

### 다양한 옵션 조건 처리 방식의 장단점 비교

#### OR 조건 활용

```SQL
select * from 거래
where (:cust_id is null or 고객ID = :cust_id)
and 거래일자 between :dt1 and :dt2
```

- 이는 옵티마이저에 의한 OR Expansion 이 일어나지 않기 때문에 **[고객ID + 거래 일자]** 순으로 인덱스를 구성해도 이를 사용할 수 없음
- **인덱스 선두 컬럼에 대한 옵션 조건에 OR 조건을 사용하면 안됨**

- 인덱스 액세스 조건으로 사용 불가
- 인덱스 필터 조건으로도 사용 불가
- 테이블 필터 조건으로만 사용 가능
- 단, 인덱스 구성 컬럼 중 하나 이상이 Not Null 컬럼이면, 18c부터 인덱스 필터 조건으로 사용 가능

> #### ✅ 장점
> 옵션 조건 컬럼이 NULL 허용 컬럼이더라도 결과집합을 보장함

#### LIKE/BETWEEN 조건 활용
- 변별력이 좋은 필수 조건이 있는 상황에서 이들 패턴을 사용하는 것은 나쁘지 않음`

```SQL
-- 인덱스 : 등록일시 + 상품분류코드
select * from 상품
where 등록일시 >= trunc(sysdate)
and 상품분류코드 like :prd_cls_cd || '%'
```

- 인덱스 선두 컬럼에 대한 옵션 조건을 `LIKE/BETWEEN` 연산자로 처리하는 것은 금물 🚫
- `NULL` 허용 컬럼에 대한 옵션 조건을 `LIKE/BETWEEN` 연산자로 처리하는 것도 금물 🚫
- 숫자형이면서 인덱스 액세스 조건으로도 사용 가능한 컬럼에 대한 옵션 조건 처리는 `LIKE` 방식을 사용해선 안됨 🚫
- `LIKE`를 옵션 조건에 사용할 때는 컬럼 값 길이가 고정적이어야 함 ✅

#### UNION ALL 활용
- 옵션 컬럼 조건도 인덱스 액세스 조건으로 사용함
- `NULL` 허용 컬럼에도 사용이 가능함

```SQL
select * from  거래
where :cust_id is null
and 거래일자 between :dt1 and :dt2
union all
select * from  거래
where :cust_id is not null
and 고객ID = :cust_id
and 거래일자 between :dt1 and :dt2
```

#### NVL/DECODE 함수 사용

- 옵션 컬럼 조건도 인덱스 액세스 조건으로 사용함
- `NULL` 허용 컬럼에는 사용 불가 🚫
- 옵션 조건 처리용 NVL/DECODE 함수를 여러 개 사용하면 그중 변별력이 가장 좋은 컬럼 기준으로 한 번만 OR Expansion이 일어남 

```SQL
select * from 거래
where 고객ID = nvl(:cust_id, 고객ID)
and 거래일자 between :dt1 and :dt2
```
```SQL
select * from 거래
where 고객ID = decode(:cust_id, null, 고객ID, :cust_id)
and 거래일자 between :dt1 and :dt2
```

&nbsp;

***

### 함수호출부하 해소를 위한 인덱스 구성

> #### PL/SQL 사용자 정의 함수가 느린 이유
> 1. 가상머신 상에서 실행되는 인터프리터 언어
> 2. 호출 시마다 컨텍스트 스위칭 발생
> 3. 내장 SQL에 댇한 Recursive Call 발생

#### 이해 안돼서 나중에 다시 정리하기!!!!



&nbsp;

***

## 4. 인덱스 설계

### 인덱스 설계가 어려운 이유

- 인덱스를 많이 설계할수록 문제가 발생함
  - DML 성능 저하 (TPS 저하)
  - 데이터베이스 사이즈 증가 (디스크 공간 낭비)
  - 데이터베이스 관리 및 운영 비용 상승
- 찾을 블록에 여유 공간이 없으면 인덱스 분할도 발생함
  - 인덱스는 정렬돼 있기 때문에 아무 블록에나 값을 입력할 수 없기 때문

&nbsp;

***

### 가장 중요한 두 가지 선택 기준

1. 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정하는 것
2. 선정한 컬럼중 '=' 으로 자주 조회하는 컬럼을 앞쪽에 두어야하는 것

&nbsp;

***

### 스캔 효율성 이외의 판단 기준

| 수행 빈도  | 업무상 중요도 | 클러스터링 팩터  | 데이터량 |
|--------|---------|-----------|-----|
| **DML 부하** | **저장 공간**   | **인덱스 관리 비용** | 등   |

- 이 중 가장 중요한 하나를 꼽자면 `수행 빈도`
- 데이터량이 적다면 굳이 인덱스를 많이 만들 필요가 없음

&nbsp;

***

### 소트 연산을 생략하기 위한 컬럼 추가

> 1. '=' 연산자로 사용한 조건절 컬럼 선정
> 2. ORDER BY 절에 기술한 컬럼 추가
> 3. '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

&nbsp;

***

### 결합 인덱스 선택도

- `선택도` : 전체 레코드 중 조건절에 의해 선택되는 레코드 비율
- `인덱스 선택도` : 인덱스 컬럼을 모두 '=' 로 조회할 때 평균적으로 선택되는 비율

> 인덱스 생성 여부를 결정할 때는 선택도가 매우 중요하지만, 컬럼 간 순서를 결정할 때는 중요하지 않음
