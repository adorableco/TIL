
## 1. NL 조인

### 기본 메커니즘

- '인덱스를 이용한 조인 방식 '
-  일반적으로 NL 조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 사용함
    - ✅ Outer 쪽 테이블은 **사이즈가 크지 않으면 인덱스를 이용하지 않을 수 있음**

&nbsp;

***

### NL 조인 실행 계획 제어

- `use_nl` 힌트 사용
```SQL
select /*+ ordered use_nl(c) */
from 사원 e, 고객 c
where e.입사일자 >= '19960101'
and c.관리사원번호 = e.사원번호
```
➡️ `ordered` : FROM 절에 기술한 순서대로 조인하라고  옵티마이저에 지시할 때 사용함

&nbsp;

***

### NL 조인 특징

1. `랜덤 액세스 위주` 의 조인 방식이라는 점
2. 조인을 한 레코드씩 순차적으로 진행한다는 점
    - 부분범위 처리가 가능한 상황에서 매우 빠른 응답 속도를 낼 수 있음
3. 다른 조인 방식과 비교할 때 **인덱스 구성 전략이 특히 중요함**

&nbsp;

***

### NL 조인 확장 메커니즘

- 모두 읽는 블록마다 **건건이 I/O Call을 발생시키는 비효율을 줄이기 위해** 고안됨


#### 테이블 Prefetch
- 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능

#### 배치 I/O
- 디스크 I/O Call 을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능



***

## 2. 소트 머지 조인
- 조인 컬럼에 인덱스가 없을 때, 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때 NL 조인 대신 **소트 머지 조인**이나 **해시 조인**을 선택함

### SGA vs. PGA

#### SGA
- 공유 메모리 영역
- 이 곳에 캐시된 데이터는 여러 프로세스가 공유할 수 있음
   - ✅ 동시에 액세스는 불가능 ➡️ Latch 존재
- `핵심 구성 요소` : 데이터 블록과 인덱스 블록을 캐싱하는 DB 버퍼 캐시

#### PGA
- (Process/Program/Private) Global Area
- 각 오라클 서버 프로세스에 할당된 메모리 영역
- 다른 프로세스와 공유하지 않는 독립적인 메모리 공간
   - 👍 래치 메커니즘이 불필요함
   - 같은 양의 데이터를 읽더라도 SGA 버퍼캐시에서 읽을 때보다 훨씬 빠름

&nbsp;

***

### 기본 메커니즘

1.  **소트 단계** : 양쪽 집합을 조인 컬럼 기준으로 정렬함
2. **머지 단계** : 정렬한 양쪽 집합을 서로 머지함

> `use_merge`  힌트로 유도함


> #### 수행 과정
> 1. outer 테이블을 읽어 조인컬럼 기준으로 정렬함
> 2. 정렬한 결과집합은 **PGA 영역에 할당된 SortArea에 저장**함
> 3. 정렬한 결과집합이 PGA에 담을 수 없을 정도로 크면, **Temp 테이블 스페이스**에 저장함
> 4. inner 테이블에 대해서도 1~3과 같은 절차를 수행함
> 5. outer 테이블과 inner 테이블을 조인함 ➡️ 이 단계는 NL 조인과 다르지 않음


✅ Sort Area에 저장한 데이터 자체가 인덱스 역할을 하므로 소트 머지 조인은 ==조인 컬럼에 인덱스가 없어도 사용할 수 있는 조인 방식==임

&nbsp;

***

### 소트 머지 조인이 빠른 이유

- 양쪽 테이블로부터 조인 대상 집합을 '일괄적으로' 읽어 PGA (or Temp 테이블 스페이스)에 저장한 후 조인함
   - PGA는 프로세스만을 위한 독립적인 메모리 공간이므로 데이터를 읽을 때 래치 획득 과정이 없음!
   - ➡️ 소트머지 조인이 대량 데이터 조인에 유리한 이유

&nbsp;

***

### 소트 머지 조인의 주용도

- 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
- 조인 조건식이 아예 없는 조인 (Cross Join, 카테시안 곱)

&nbsp;

***

### 소트 머지 조인 특징 요약

1. 조인을 위해 실시간으로 인덱스를 생성하는 것과 같음
2. 조인 컬럼에 대한 인덱스 유무에 영향을 받지 않음
3. 스캔 위주의 액세스 방식을 사용함

&nbsp;

***


## 3. 해시 조인

- 대량 데이터 조인할 때 NL 조인보다 훨씬 빠르고, 일정한 성능을 보임

### 기본 메커니즘

> 1. **Build** 단계 : 작은 쪽 테이블 (Build Input) 을 읽어 해시 테이블(해시 맵)을 생성함
> 2. **Probe** 단계 : 큰 쪽 테이블 (Probe Input) 을 읽어 해시 테이블을 탐색하면서 조인함

✅ `use_hash` 힌트로 유도함

&nbsp;

#### 수행 과정
> 1. **Build** 단계 : 조건에 해당하는 outer 테이블의 데이터를 읽어 해시 테이블을 생성함
     > 	- 이때 조인컬럼을 해시 테이블 키 값으로 사용함
> 	- 해시 함수에 입력해서 반환된 값을 해시 체인으로 찾고, 그 해시 체인에 데이터를 연결함
> 	- 해시 테이블은 PGA 영역에 할당된 Hash Area에 저장함 ➡️ 해시 테이블이 너무 크면 Temp 테이블 스페이스에 저장
> 2. **Probe** 단계 : 조건에 해당하는 inner 테이블의 데이터를 하나씩 읽어 앞서 생성한 해시 테이블을 탐색함
     > 	- 해시 함수에 조인 컬럼을 입력해서 반환된 값으로 해시 체인을 찾음
> 	- 해시 체인이 있으면 조인을 하고 없으면 조인 X


> 🔥 해시 테이블에는 조인 키 값뿐만 아니라 SQL에 사용한 컬럼을 모두 저장함
> - 그래야 래치 획득 과정없이 PAG에서 조인한다는 장점을 살릴 수 있음
> - 나머지 컬럼이 없으면 `ROWID` 로 다시 테이블 블록을 액세스해야하지 때문
### 해시 조인이 빠른 이유

- 해시 테이블을 PGA 영역에 할당하기 때문
   - 래치 획득 과정이 필요 없음

> ✅ 해시 조인도 Build Input 과 Probe Input 각 테이블을 읽을 때는 DB 버퍼캐시를 경유함
> - ➡️ 이때 인덱스를 이용하기도 함
> - ➡️  이 과저에서 생기는 버퍼 캐시 탐색 비용과 랜덤 액세스 부하가 있을 수 있음