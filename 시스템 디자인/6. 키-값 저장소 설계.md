- [CAP 정리](#cap-정리)
- [데이터 파티션](#데이터-파티션)
- [데이터 다중화](#데이터-다중화)
- [데이터 일관성](#데이터-일관성)
  - [정족수 합의 (Quorum Consensus) 프로토콜](#정족수-합의-quorum-consensus-프로토콜)
  - [비일관성 해소 기법: 데이터 버저닝](#비일관성-해소-기법-데이터-버저닝)
- [장애 처리](#장애-처리)
- [일시적 장애 처리](#일시적-장애-처리)
- [영구적 장애 처리](#영구적-장애-처리)
  - [반-엔트로피 (anti-entropy) 프로토콜](#반-엔트로피-anti-entropy-프로토콜)
  - [머클 트리](#머클-트리)
- [데이터 센터 장애 처리](#데이터-센터-장애-처리)
***

### CAP 정리

- `데이터 일관성 (consistency)`, `가용성 (availability)`, `파티션 감내 (partition tolerance)` 라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리

- **데이터 일관성**
    - 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 함
- **가용성**
    - 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 함
- **파티션 감내**
    - 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미함
    - 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 함

> ✅ 네트워크 장애는 피할 수 없으므로 파티션 감내를 놓칠 수는 없음

&nbsp;

***

### 데이터 파티션

- 대규모  애플리케이션에서는 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능함
- `안정 해시`로 해결

#### 장점

- **규모 확장 자동화 (automatic scaling)**
    - 시스템 부하에 따라 서버가 자동으로 추가되거나 삭제되도록 만들 수 있음
- **다양성 (heterogeneity)**
    - 각 서버의 용량에 맞게 가상 노드의 수를 조정할 수 있음

&nbsp;

***

### 데이터 다중화

- 높은 가용성과 안정성을 확보하기 위해 데이터를 N개 서버에 비동기적으로 다중화해야 함
- 안정 해시의 해시 링에서 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관하면 됨


> 🤧 가상 노드를 사용하면 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작을 수 있음
> - ➡️ 같은 물리 서버를 중복 선택하지 않도록 주의해야 함

&nbsp;

***

### 데이터 일관성

- 여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 함


#### 정족수 합의 (Quorum Consensus) 프로토콜

- 읽기/쓰기 연산 모두에 일관성 보장 가능

> N = 사본 개수
> W = 쓰기 연산에 대한 정족수
> R = 읽기 연산에 대한 정족수

- R = 1, W = N :  빠른 읽기 연산에 최적화된 시스템
- W = 1, R = N : 빠른 쓰기 연산에 최적화된 시스템
- W + R > N : 강한 일관성이 보장됨 (보통 N = 3, W = R = 2)
- W + R <= N : 강한 일관성이 보장되지 않음


> #### ✅  정리
> - **W 나 R의 값이 1보다 큰 경우** : 데이터 일관성의 수준은 향상되지만 응답은 느려짐
> - **W 나 R 이 1인 경우** : 응답속도는 빠를 것


#### 일관성 모델

- **강한 일관성 (strong consistency)**
    - 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환함
    - 고가용성 시스템에는 적합하지 않음
- **약한 일관성 (weak consistency)**
    - 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못함
- **결과적 일관성 (eventual consistency)**
    - 갱신 결과가 결국에는 모든 사본에 반영되는 모델
    - 약한 일관성의 한 형태

&nbsp;


#### 비일관성 해소 기법: 데이터 버저닝

##### 벡터 시계를 이용

- **[서버, 버전]** 의 순서쌍을 데이터에 매다는 것
- 어떤 버전이 선행 버전인지, 후행 버전인지, 아니면 다른 버전과 충돌이 있는지 판별하는데 사용함

##### 단점

1. 충돌 감지 및 해소 로직이 클라이언트에 들어가야 하므로, 클라이언트 구현이 복잡해짐
2. **[서버:버전]** 의 순서쌍 개수가 굉장히 빨리 늘어남

&nbsp;

***

### 장애 처리

#### 장애 감지

- 보통 두 대 이상의 서버가 똑같이 서버 A의 장애를 보고해야 해당 서버에 실제로 장애가 발생했다고 간주하게 됨

##### 가십 프로토콜

- 분산형 장애 감지 솔루션
- [동작원리](https://wiki1.kr/index.php/%EA%B0%80%EC%8B%AD)

&nbsp;

***

### 일시적 장애 처리

#### 느슨한 정족수 (sloppy quorum) 접근법

- 정족수 요구사항을 강제하는 대신, 쓰기 연산을 수행할 W개의 건강한 서버와 읽기 연산을 수행할 R개의 건강한 서버를 해시 링에서 고름
    - 이때 장애 상태인 서버는 무시
- 장애 상태인 서버로 가는 요청은 다른 서버가 잠시 맡아 처리하고 그동안 발생한 변경사항은 해당 서버가 복구되었을 때 일괄 반영하여 데이터 일관성을 보존함
    - 이를 위한 단서를 남기기 위해 단서 후 임시 위탁 (hinted handoff) 기법을 사용함

&nbsp;

***

### 영구적 장애 처리

#### 반-엔트로피 (anti-entropy) 프로토콜

- 사본들을 비교하여 최신 버전으로 갱신하는 과정
- [Merkle 트리](https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%8A%B8%EB%A6%AC)를 사용함


> ✅ **일시적 장애 처리** 는 당장은 정상인 서버를 통해 처리하도록 조치를 취하는 것이고 **영구적 장애  처리** 는 장애를 감지하면 바로 정상 서버로부터 동기화를 할 수 있도록 하는 것.
> - **일시적 장애 처리** 는 이후에 정상으로 되돌리도록 동기화 처리가 돼야 함!


#### 머클 트리

- 해시 트리라고도 불림
- 각 노드에 그 자식 노드들에 보관된 값의 해시, 또는 자식 노드들의 레이블로부터 계산된 해시값을 레이블로 붙여두는 트리
- 대규모 자료 구조의 내용을 효과적이면서도 보안상 안전한 방법으로 검증할 수 있음

&nbsp;

***

### 데이터 센터 장애 처리

- 데이터를 여러 데이터 센터에 다중화해야 함

