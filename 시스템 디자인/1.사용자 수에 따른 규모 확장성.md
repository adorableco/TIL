<!-- @format -->

## 1. 사용자 수에 따른 규모 확장성

### 수직적 규모 확장 VS 수평적 규모 확장

#### 수직적 규모 확장 (scale up)

- 서버에 고사양 자원을 추가하는 행위

> #### 단점
>
> - 한계가 있음
> - 서버에 장애가 발생하면 서비스가 완전히 중단됨

#### 수평적 규모 확장 (scale out)

- 더 많은 서버를 추가하여 성능을 개선하는 행위

### 데이터베이스 다중화

#### master - slave 관계

- **쓰기 연산**은 마스터에서만 지원
- 부 데이터베이스는 주 데이터베이스로부터 사본을 전달 받음 -> **읽기 연산**만 지원

```
✅ 대부분의 애플리케이션은 읽기 연산 >>>> 쓰기 연산이므로 보통 부 데이터베이스 개수가 더 많음
```

### 캐시

- 캐시 계층 : 데이터가 잠시 보관되는 곳으로 성능이 개선될 뿐만 아니라 캐시 계층의 규모를 독립적으로 확장시키는 것도 가능

#### 고려할 점

- `사용하면 좋은 경우` : 데이터 갱신은 자주 일어나지 않지만 참조는 자주 일어나는 경우
- `보관해야할 데이터` : 휘발성 데이터
- 일관성은 어떻게 유지할 것인지
- 장애에는 어떻게 대처할 것인지
- 캐시 메모리의 크기는 어느 정도로 구성할 것인지
- 데이터 방출 정책은 어떻게 정할 것인지
  - LRU
  - LFU
  - FIFO

### CDN
- 정적 콘텐츠를 전송하는 데 쓰이는, **지리적으로 분산된** 서버의 네트워크

#### 고려할 점

- 적절한 만료 시한 설정 : 시의성이 중요한 콘텐츠인 경우 더더욱
- 콘텐츠 무효화 방법
  - CDN 서비스 사업자가 제공하는 API를 사용하여 콘텐츠 무효화
  - 오브젝트 버저닝 (object versioning)
    - e.g.) `image.jpg?v=3`

### 메시지 큐
- 서비스 또는 서버 간 결합이 느슨해져서 **규모 확장성이 보장되어야 하는** 안정적 애플리케이션을 구성하기 좋음
- 오래 걸리는 작업을 비동기적으로 처리함으로써 처리 시간을 줄일 수 있음

### 데이터베이스의 규모 확장

#### 수직적 확장

#### 수평적 확장 - 샤딩 (sharding)
- 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술
- 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없음
- `샤딩 키` 를 어떻게 정하느냐가 가장 중요함

<blockquote>
  <b>샤딩 도입 시 발생할 수 있는 문제점</b>
  <ul>
    <li>데이터의 재 샤딩 : 샤드 간 데이터 분포가 균등하지 못하여 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치해야 하는 경우</li>
    <li>유명인사 문제 (== hotspot 문제) : 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제 </li>
    <li>조인과 비정규화 : 하나의 DB를 여러 샤드 서버로 쪼개면 데이터를 조인하기가 힘들어짐 -> DB를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하기</li>

</ul>
</blockquote>