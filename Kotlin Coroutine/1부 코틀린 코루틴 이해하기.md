
## 1. 코틀린 코루틴을 배워야 하는 이유

1. 기존의 방식보다 훨씬 더 많은 것을 제공함
2. **멀티플랫폼에서 작동**시킬 수 있기 때문에 코틀린을 사용하는 모든 플랫폼 (JVM, iOS 등) 에서 사용 가능
3. 기존 코드 구조를 광범위하게 뜯어 고칠 필요가 없음

## 2. 시퀀스 빌더

- 코틀린의 시퀀스: 컬렉션과 비슷한 개념이지만, 필요할 때마다 값을 하나씩 계산하는 지연(lazy) 처리를 함
    - 요구되는 연산을 최소한으로 수행
    - 무한정이 될 수 있음
    - 메모리 사용이 효율적임

- `sequence` 함수를 사용하여 구현되며, 코루틴을 기반으로 작동함
```Kotlin
val mySequence = sequence {
    yield(1)  // 첫 번째 요소
    yield(2)  // 두 번째 요소
    yield(3)  // 세 번째 요소
}

fun main() {
    for (value in mySequence) {
        println(value)
    }
}
```

- ➡️ 중단이 가능하므로 main 함수와 시퀀스 제너레이터가 번갈아가면서 실행됨
    - 중단  후에 재실행하면 중단했던 지점부터 시작함
### 중요한 함수

- `yield(value: T)`
    - 특정 값을 시퀀스에 추가합니다.

- `yieldAll(collection: Iterable<T>)`
    - 컬렉션, 배열, 또는 다른 시퀀스를 순회하며 모든 값을 추가합니다.

- `yieldAll(sequence: Sequence<T>)`
    - 다른 시퀀스의 값을 모두 추가합니다.

> ✅ 시퀀스 빌더는 `yield` 가 아닌 중단 함수를 사용하면 안됨


## 3. 중단은 어떻게 작동할까?

- 코루틴은 중단되었을 때 `Continuation` 객체를 반환함
    - **멈췄던 곳에서 다시 코루틴을 실행할 수 있음**

### 재개

#### 중단 함수 (suspend)
- 코루틴을 중단할 수 있는 함수
- 중단 함수는 반드시 코루틴 or 다른 중단 함수에 의해 호출되어야 함

```Kotlin
suspend fun main() {
	println("Before")

	suspendCoroutine<Unit> { continuation -> 
		println("Before too")
	}

	println("After")
}
```

- `suspendCoroutine` 에 인자로 들어간 람다 함수는 중단되기 전에 실행됨
    - 이 함수는 `continuation` 객체를 인자로 받음 ➡️ 중단되기 전에 실행되도록 하기 위해서


```Kotlin
suspend fun main(){  
    println("Before")  
  
    suspendCoroutine<Unit> { continuation ->  
        thread {  
            println("Suspended")  
            Thread.sleep(1000)  
            continuation.resume(Unit)  
            println("Resumed")  
        }    }    println("After")  
}
```
- 잠깐 동안 정지된 뒤 재개되는 다른 스레드를 실행할 수도 있음

### ScheduledExecutorService 사용하기

-  **단일 스레드 기반의 스케줄링 가능한 실행기(ScheduledExecutorService)** 를 생성하는 메서드
    - 이 메서드는 특정 시간 이후에 작업을 실행하거나, 주기적으로 반복 실행할 수 있는 기능을 제공함
```Kotlin
private val executor = Executors.newSingleThreadScheduledExecutor()  {  
    Thread(it, "scheduler").apply { isDaemon = true }  
}  
  
suspend fun delay(timeMillis: Long): Unit = suspendCoroutine { cont ->  
    executor.schedule({  
        cont.resume(Unit)  
    }, timeMillis, TimeUnit.MILLISECONDS)  
}  
  
suspend fun main(){  
    println("Before")  
  
    delay(2000)  
    println("After")  
}
```


### 값으로 재개

- `suspendCoroutine` 을 호출할 때 컨티뉴에이션 객체로 반환될 값의 타입을 지정할 수 있음
- `resume`을 통해 반환되는 값은 **반드시 지정된 타입과 같은 타입이어야 함**

```Kotlin
val ret: Unit =  
    suspendCoroutine<Unit> { cont: Continuation<Unit> ->  
        cont.resume(Unit)  
    }
```


### 예외로 재개

- `resumeWithException` 이 호출되면 중단된 지점에서 인자로 넣어준 예외를 던짐

```Kotlin
class MyException : Throwable("Just an exception")  
  
suspend fun main() {  
    try {  
        suspendCoroutine<Unit> { cont ->  
            cont.resumeWithException(MyException())  
        }    } catch (e: MyException) {  
        println("Caught exception!!!")  
    }}
```



### 함수가 아닌 코루틴을 중단시키는 것

```Kotlin
// 메모리 누수가 발생할 수 있으므로 이렇게 구현 X
var continuation: Continuation<Unit>? = null  
  
suspend fun suspendAndSetContinuation() {  
    suspendCoroutine<Unit> {cont ->  
        continuation = cont  
    }  
}  
  
suspend fun main() {  
    println("Before")  
  
    suspendAndSetContinuation()  
    continuation?.resume(Unit)  
  
    println("After")  
  
}
```

- 코루틴이 일시 중단되면, 그 이후의 코드는 **재개(resume)** 될 때까지 실행되지 않음
  •	즉, `continuation?.resume(Unit)`과 `println("After")`는 아직 실행되지 않는 것!