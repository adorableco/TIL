[6. 코루틴 빌더](#6-코루틴-빌더)

***

## 6. 코루틴 빌더

- 중단 함수를 연속으로 호출하면 시작되는 지점이 있음
    - 이 역할을 **코루틴 빌더**가 함

### kotlinx.coroutines 라이브러리에서 제공하는 코루틴 빌더

- **launch**
- **runBlocking**
- **async**

### launch 빌더

- thread 함수를 호출하여 새로운 스레드를 시작하는 것과 비슷함

#### 예제

```Kotlin
fun main(){  
    GlobalScope.launch {  
        delay(1000L)  
        println("World!")  
    }  
    GlobalScope.launch {  
        delay(1000L)  
        println("World!")  
    }  
    GlobalScope.launch {  
        delay(1000L)  
        println("World!")  
    }  
    GlobalScope.launch {  
        delay(1000L)  
        println("World!")  
    }  
    println("Hello,")  
    Thread.sleep(2000L)  
}
// Hello,  
// (1초 후)  
// World!  
// World!  
// World!
```

- launch 함수
    - `CoroutineScope` 인터페이스의 확장 함수
- 실제 현업에서는 `GlobalScope` 의 사용을 지양해야 함

- 스레드를 잠들게 하지 않으면 메인 함수는 코루틴을 실행하자마자 끝나버림
    - `main` 함수 끝에 `Thread.sleep(2000L)` 을 호출한 것

### runBlocking 빌더

- 코루틴이 스레드를 블로킹하지 않고 작업을 중단시키기만 하는 것이 일반적
    - But, 블로킹이 필요한 경우도 있음
        - 메인 함수의 경우 프로그램을 너무 빨리 끝내지 않기 위해 스레드를 블로킹해야 함

#### 예제

```Kotlin
fun main(){  
    runBlocking {  
        delay(1000L)  
        println("World!")  
    }  
    runBlocking {  
        delay(1000L)  
        println("World!")  
    }  
    runBlocking {  
        delay(1000L)  
        println("World!")  
    }  
    println("Hello,")  
}  
// (1초 후)  
// World!  
// (1초 후)  
// World!  
// (1초 후)  
// World!  
// Hello,
```

- `runBlocking` 내부에서 호출한 delay 함수가 `Thread.sleep(1000L)` 과 비슷하게 작동함
    - 이 방식이 좀 더 유용함

##### 사용하는 경우

1. 프로그램이 끝나는 걸 방지하기 위해 스레드를 블로킹할 필요가 있는 메인 함수
2. 스레드를 블로킹할 필요가 있는 유닛 테스트

> ✅ 현재는 거의 사용하지 않음
> - 유닛 테스트에서는 코루틴을 가상 시간으로 실행시키는 `runTest`가 주로  사용됨
> - main 함수는 `runBlocking` 대신에 `suspend` 를 붙여 중단 함수로 만드는 방법을 주로 사용함


### async 빌더

- launch 와 비슷하지만 **값을 생성하도록** 설계되어 있음
- `async` 함수는 `Deferred<T>` 타입의 객체를 리턴함
    - T는 생성되는 값의 타입
- `Deferred` 에는 **작업이 끝나면 값을 반환하는 중단 메서드** `await`  가 있음

#### 예제
```Kotlin
val resultDeferred: Deferred<Int> = GlobalScope.async {  
    delay(1000L)  
    42  
}  
// 다른 작업 수행 ...
val result: Int = resultDeferred.await()  // (1초 후)  
println(result)   // 42
```

- 호출되지마자 코루틴을 즉시 시작함
    - 몇 개의 작업을 한 번에 시작하고 모든 결과를 한꺼번에 기다릴 때 사용
- 값이 생성되기 전에 **await** 를 호출하면 값이 나올 때까지 기다리게 됨

> ✅ `async` 는 값을 생성할 때 사용하고 `launch` 는 값이 필요하지 않을 때 사용하기



### 구조화된 동시성

- 동시성 프로그래밍에서 작업과 하위 작업 간의 관계를 명확히 정의하여, 코드의 가독성과 안정성을 높이고 오류 처리 및 취소를 간소화하는 접근 방식

#### 부모-자식 관계의 중요한 특징

- 자식은 부모로부터 컨텍스트를 상속받음
- 부모는 모든 자식이 작업을 마칠 때까지 기다림
- 부모 코루틴이 취소되면 자식 코루틴도 취소됨
- 자식 코루틴에서 에러가 발생하면, 부모 코루틴 또한 에러로 소멸함

#### 예제

```Kotlin
fun main() = runBlocking {  
    GlobalScope.launch {  
        delay(1000L)  
        println("World!")  
    }  
    GlobalScope.launch {  
        delay(2000L)  
        println("World!")  
    }  
    println("Hello,")  
    // delay(3000L)  
}
```

- `async` 와 `launch` 가 `CoroutineScope` 의 확장함수이기 때문에 **GlobalScope**를 붙인 것인데, runBlocking의 block 파라미터의 리시버 타입이 `CoroutineScope` 이기 때문에 **GlobalScope** 를 제외할 수 있음
    - [코틀린 리시버에 대한 상세한 설명](https://www.perplexity.ai/search/gujohwadoen-dongsiseong-gwangy-b560vr9MTvCgkE1cTjPNDA#3) (나중에 따로 정리하기!)

> ✅ **runBlocking** 은 `CoroutineScope` 의 확장 함수가 아님
> - **runBlocking** 은 자식이 될 수 없으며 루트 코루틴으로만 사용 가능



### `coroutineScope` 사용하기

- 람다 표현식이 필요로 하는 스코프를 만들어 주는 중단 함수
- 중단 함수를 `coroutineScope` 와 함께 사용하는 것도 가능함
    - 메인 함수와 `runBlocking` 을 함께 사용하는 것보다 세련된 방법임
#### 중단 함수에선 스코프를 어떻게 처리할까?

- 중단 함수 내부에서 중단될 수 있지만 함수 내에는 스코프가 없음
- 코루틴 빌더가 사용할 스코프를 만들어주는 중단 함수인 `coroutineScope` 함수를 사용하는 것이 바람직함

```Kotlin
suspend fun getArticlesForUser(  
    userToken: String?  
): List<ArticleJson> = coroutineScope {  
    val articles = async {articleRepository.getArticles() }  
    val user = userService.getUser(userToken)  
    articles.await()  
        .filter{ canSeeOnList(user,it )}  
        .map{ toArticleJson(it) }  
}
```